{"instance_id": "Choser_CVE-2016-10504", "hits": [{"docid": "wrapping/java/openjp2/java-sources/org/openJpeg/OpenJPEGJavaEncoder.java", "score": 914.5789184570312}, {"docid": "src/bin/jpip/opj_viewer/src/PnmImage.java", "score": 561.903076171875}, {"docid": "wrapping/java/openjp2/java-sources/org/openJpeg/OpenJPEGJavaDecoder.java", "score": 459.9679870605469}, {"docid": "src/bin/jpip/opj_viewer/src/ImageViewer.java", "score": 418.4393005371094}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/ImageViewer.java", "score": 418.4393005371094}, {"docid": "src/bin/jpip/opj_viewer/src/ImgdecClient.java", "score": 371.9053039550781}, {"docid": "src/bin/jpip/opj_viewer/src/JPIPHttpClient.java", "score": 344.25189208984375}, {"docid": "src/bin/jpip/opj_viewer/src/MML.java", "score": 323.66558837890625}, {"docid": "src/bin/jpip/opj_viewer/src/RegimViewer.java", "score": 281.2066955566406}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/JP2XMLparser.java", "score": 213.8126983642578}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/ImageWindow.java", "score": 201.55929565429688}, {"docid": "src/bin/jpip/opj_viewer/src/ImageWindow.java", "score": 201.5570068359375}, {"docid": "src/bin/jpip/opj_viewer/src/ImageManager.java", "score": 179.8240966796875}, {"docid": "src/bin/wx/OPJViewer/about/about.htm", "score": 163.00819396972656}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/OptionPanel.java", "score": 89.86389923095703}, {"docid": "src/bin/jpip/opj_viewer/src/ResizeListener.java", "score": 48.21889877319336}, {"docid": "appveyor.yml", "score": 24.44300079345703}, {"docid": "tools/abi-tracker/openjpeg.json", "score": 17.464799880981445}], "function_summary": "This code snippet is from a function that allocates data memory for an encoding code block in the OpenJPEG library (a JPEG 2000 implementation).\n\n**Main functionality:**\n\n1. **Calculates required data size**: Computes the memory needed based on the code block's dimensions (width \u00d7 height) multiplied by the size of a 32-bit unsigned integer (`OPJ_UINT32`).\n\n2. **Checks if reallocation is needed**: Compares the calculated size (`l_data_size`) against the currently allocated size (`p_code_block->data_size`) to determine if more memory is required.\n\n**Key operations:**\n- Uses the code block's coordinate bounds (`x0`, `y0`, `x1`, `y1`) to calculate width and height\n- Multiplies by `sizeof(OPJ_UINT32)` to get the total bytes needed\n- The comparison at line 1188 triggers memory reallocation if the current allocation is insufficient\n\nThis is part of the tile coding/decoding (TCD) module's memory management system, specifically handling the dynamic allocation of buffer space for code blocks during JPEG 2000 encoding. The function ensures that each code block has adequate memory allocated before encoding operations begin."}
{"instance_id": "Choser_CVE-2016-7445", "hits": [{"docid": "wrapping/java/openjp2/java-sources/org/openJpeg/OpenJPEGJavaEncoder.java", "score": 1606.96337890625}, {"docid": "wrapping/java/openjp2/java-sources/org/openJpeg/OpenJPEGJavaDecoder.java", "score": 1287.6917724609375}, {"docid": "src/bin/jpip/opj_viewer/src/PnmImage.java", "score": 1223.7117919921875}, {"docid": "src/bin/jpip/opj_viewer/src/ImgdecClient.java", "score": 1042.3389892578125}, {"docid": "src/bin/jpip/opj_viewer/src/ImageViewer.java", "score": 883.4006958007812}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/ImageViewer.java", "score": 883.4006958007812}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/JP2XMLparser.java", "score": 759.6820068359375}, {"docid": "src/bin/jpip/opj_viewer/src/JPIPHttpClient.java", "score": 696.5059204101562}, {"docid": "tools/abi-tracker/compat_report/2.1_to_current/compat_report.html", "score": 687.825927734375}, {"docid": "src/bin/jpip/opj_viewer/src/RegimViewer.java", "score": 661.2269287109375}, {"docid": "src/bin/jpip/opj_viewer/src/ImageWindow.java", "score": 492.5000915527344}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/ImageWindow.java", "score": 492.5000915527344}, {"docid": "src/bin/jpip/opj_viewer/src/ImageManager.java", "score": 458.7496032714844}, {"docid": "src/bin/wx/OPJViewer/about/about.htm", "score": 417.7933044433594}, {"docid": "src/bin/jpip/opj_viewer/src/MML.java", "score": 287.4919128417969}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/OptionPanel.java", "score": 201.3134002685547}, {"docid": "tools/abi-tracker/openjpeg.json", "score": 93.90190124511719}, {"docid": "appveyor.yml", "score": 67.0824966430664}, {"docid": "src/bin/jpip/opj_viewer/src/ResizeListener.java", "score": 66.03250122070312}], "function_summary": "This code snippet contains utility functions for parsing PNM (Portable aNyMap) image file headers. The main components are:\n\n**Helper Functions:**\n- `skip_white()`: Skips whitespace characters in a string, returning NULL if newline/carriage return is encountered\n- `skip_int()`: Parses an integer from a string, temporarily null-terminating to use `atoi()`\n- `skip_idf()`: Extracts an identifier (alphabetic characters and underscores) from a string\n\n**Main Function:**\n- `read_pnm_header()`: Parses PNM image headers for formats P1-P7\n  - Validates the magic number starts with 'P'\n  - Handles different PNM formats (1-7)\n  - For P7 format: parses structured headers with keywords like WIDTH, HEIGHT, DEPTH, MAXVAL, TUPLTYPE\n  - For other formats: parses width, height, and maxval in sequence\n  - Skips comment lines starting with '#'\n  - Validates constraints (maxval \u2264 65535, positive dimensions)\n  - Sets various flags in the header structure based on tuple type (grayscale, RGB, etc.)\n  - Marks header as valid (`ph->ok = 1`) when all required fields are present\n\nThe code handles both the simpler P1-P6 formats and the more complex P7 format with its keyword-based header structure, providing robust parsing with error checking and validation."}
{"instance_id": "Choser_CVE-2016-9118", "hits": [{"docid": "wrapping/java/openjp2/java-sources/org/openJpeg/OpenJPEGJavaEncoder.java", "score": 1612.93408203125}, {"docid": "wrapping/java/openjp2/java-sources/org/openJpeg/OpenJPEGJavaDecoder.java", "score": 1278.6494140625}, {"docid": "src/bin/jpip/opj_viewer/src/PnmImage.java", "score": 1235.8668212890625}, {"docid": "src/bin/jpip/opj_viewer/src/ImgdecClient.java", "score": 995.3519287109375}, {"docid": "src/bin/jpip/opj_viewer/src/ImageViewer.java", "score": 897.8690185546875}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/ImageViewer.java", "score": 897.8690185546875}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/JP2XMLparser.java", "score": 781.6329956054688}, {"docid": "src/bin/jpip/opj_viewer/src/JPIPHttpClient.java", "score": 676.84619140625}, {"docid": "src/bin/jpip/opj_viewer/src/RegimViewer.java", "score": 672.61181640625}, {"docid": "src/bin/jpip/opj_viewer/src/ImageWindow.java", "score": 489.5647888183594}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/ImageWindow.java", "score": 489.5647888183594}, {"docid": "src/bin/jpip/opj_viewer/src/ImageManager.java", "score": 443.3028869628906}, {"docid": "src/bin/wx/OPJViewer/about/about.htm", "score": 420.4245910644531}, {"docid": "src/bin/jpip/opj_viewer/src/MML.java", "score": 283.7673034667969}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/OptionPanel.java", "score": 186.90289306640625}, {"docid": "tools/abi-tracker/openjpeg.json", "score": 98.59020233154297}, {"docid": "appveyor.yml", "score": 68.22470092773438}, {"docid": "src/bin/jpip/opj_viewer/src/ResizeListener.java", "score": 58.40370178222656}], "function_summary": "This code snippet determines the number of image components (color channels) based on the PNM (Portable Anymap) image format type. It's part of a larger function that converts PNM images to OpenJPEG format.\n\nThe snippet uses a switch statement to map PNM format codes to the appropriate number of components:\n\n- **Format 1 & 4**: ASCII and raw bitmap formats respectively - these are monochrome/binary images, so they have 1 component\n- **Format 2 & 5**: ASCII and raw greymap formats respectively - these are grayscale images, so they also have 1 component\n\nThe pattern continues for other formats (not shown in this snippet):\n- Formats 3 & 6 would be RGB pixmaps (3 components)\n- Format 7 would be arbitrary PAM format (variable components based on header)\n\nThis component count determination is crucial for proper image processing, as it tells the conversion function how many color channels to expect and allocate memory for. The `numcomps` variable is later used to initialize image component parameters and create the appropriate OpenJPEG image structure with the correct number of color planes."}
{"instance_id": "Choser_CVE-2017-14164", "hits": [{"docid": "wrapping/java/openjp2/java-sources/org/openJpeg/OpenJPEGJavaEncoder.java", "score": 1649.24365234375}, {"docid": "wrapping/java/openjp2/java-sources/org/openJpeg/OpenJPEGJavaDecoder.java", "score": 845.7462768554688}, {"docid": "src/bin/jpip/opj_viewer/src/ImgdecClient.java", "score": 490.0360107421875}, {"docid": "src/bin/jpip/opj_viewer/src/PnmImage.java", "score": 440.31561279296875}, {"docid": "src/bin/jpip/opj_viewer/src/JPIPHttpClient.java", "score": 437.7225036621094}, {"docid": "src/bin/jpip/opj_viewer/src/ImageViewer.java", "score": 384.0445861816406}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/ImageViewer.java", "score": 384.0445861816406}, {"docid": "src/bin/wx/OPJViewer/about/about.htm", "score": 377.9921875}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/JP2XMLparser.java", "score": 339.53509521484375}, {"docid": "src/bin/jpip/opj_viewer/src/ImageWindow.java", "score": 260.7724914550781}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/ImageWindow.java", "score": 260.7724914550781}, {"docid": "src/bin/jpip/opj_viewer/src/RegimViewer.java", "score": 234.93809509277344}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/OptionPanel.java", "score": 208.61830139160156}, {"docid": "src/bin/jpip/opj_viewer/src/ImageManager.java", "score": 194.14340209960938}, {"docid": "src/bin/jpip/opj_viewer/src/MML.java", "score": 158.656005859375}, {"docid": "src/bin/jpip/opj_viewer/src/ResizeListener.java", "score": 76.88150024414062}, {"docid": "tools/abi-tracker/openjpeg.json", "score": 54.110599517822266}, {"docid": "appveyor.yml", "score": 42.80739974975586}], "function_summary": "This code snippet is a function called `opj_j2k_write_sot` that writes a SOT (Start of Tile-part) marker to a JPEG 2000 codestream. The function is part of the OpenJPEG library's J2K encoder.\n\n**Main functionality:**\n1. **Writes SOT marker header**: Outputs the 2-byte SOT marker identifier (`J2K_MS_SOT`)\n2. **Writes marker length**: Outputs the fixed length value of 10 bytes (`Lsot`)\n3. **Writes tile number**: Outputs the current tile number being processed (`Isot`)\n\n**Key operations:**\n- Uses `opj_write_bytes()` to write binary data to the output buffer\n- Increments the data pointer after each write operation\n- Follows JPEG 2000 standard SOT marker format\n\n**Important details:**\n- The function takes validation parameters but marks the stream and manager as unused\n- Returns the number of bytes written (12) through the `p_data_written` parameter\n- Includes placeholder space for additional SOT fields (Psot, TPsot, TNsot) that are written elsewhere\n- Contains assertions for parameter validation\n- Includes commented code for JPWL (JPEG 2000 Part 11) extensions\n\nThis is a low-level encoding function that formats tile-part headers according to the JPEG 2000 specification."}
{"instance_id": "uuykea_CVE-2020-10251", "hits": [{"docid": "www/architecture.html", "score": 3285.818115234375}, {"docid": "www/magick-core.html", "score": 2018.4166259765625}, {"docid": "www/porting.html", "score": 1985.3819580078125}, {"docid": "www/api/Image++.html", "score": 1859.42333984375}, {"docid": "www/api/constitute.html", "score": 1851.9903564453125}, {"docid": "www/Magick++/Image.html", "score": 1841.0111083984375}, {"docid": "www/Magick++/Image++.html", "score": 1840.995849609375}, {"docid": "www/magick-wand.html", "score": 1798.64697265625}, {"docid": "www/api/image.html", "score": 1757.2015380859375}, {"docid": "www/api/blob.html", "score": 1739.7828369140625}, {"docid": "www/api/cache.html", "score": 1649.7109375}, {"docid": "www/api/magick-image.html", "score": 1614.2103271484375}, {"docid": "www/perl-magick.html", "score": 1582.1490478515625}, {"docid": "www/Magick++/STL.html", "score": 1545.7073974609375}, {"docid": "www/command-line-options.html", "score": 1516.107666015625}, {"docid": "www/api/magick-property.html", "score": 1508.1324462890625}, {"docid": "www/api/cache-view.html", "score": 1504.7872314453125}, {"docid": "www/escape.html", "score": 1475.97607421875}, {"docid": "www/api/list.html", "score": 1459.786376953125}, {"docid": "www/api/module.html", "score": 1458.7060546875}], "function_summary": "This code snippet is from ImageMagick's HEIC (High Efficiency Image Format) coder module. The main functionality includes:\n\n**Reading HEIC Images:**\n- `ReadHEICImage()` - Main function that reads HEIC files using the libheif library\n- `ReadHEICImageByID()` - Reads individual images by their ID from the HEIC container\n- `ReadHEICColorProfile()` - Extracts ICC color profiles from HEIC images\n- `ReadHEICExifProfile()` - Extracts EXIF metadata from HEIC images\n- Supports multi-image HEIC files and handles YCbCr colorspace conversion\n\n**Writing HEIC Images:**\n- `WriteHEICImage()` - Encodes images to HEIC format using libheif\n- Converts RGB images to YCbCr colorspace for encoding\n- Supports quality settings and metadata preservation\n- `WriteProfile()` - Embeds EXIF and XMP metadata into output files\n\n**Format Detection:**\n- `IsHEIC()` - Identifies HEIC files by checking magic bytes (\"ftyp\" followed by \"heic\", \"heix\", or \"mif1\")\n\n**Module Registration:**\n- `RegisterHEICImage()` and `UnregisterHEICImage()` - Register the HEIC format with ImageMagick's coder system\n\nThe code handles both reading and writing operations, metadata preservation, multi-image sequences, and proper memory management while interfacing with the external libheif library for actual HEIC processing."}
{"instance_id": "uuykea_CVE-2019-20162", "hits": [{"docid": "doc/configuration.html", "score": 948.1956787109375}, {"docid": "gui/mpegu-core.js", "score": 732.2073974609375}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/GpacCallback.java", "score": 710.8331298828125}, {"docid": "gui/iphone_wm_gui.js", "score": 669.55908203125}, {"docid": "gui/mpegu-wm.js", "score": 653.3936767578125}, {"docid": "gui/gui_old.js", "score": 592.9044189453125}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/Osmo4.java", "score": 588.2985229492188}, {"docid": "gui/gwlib.js", "score": 577.0881958007812}, {"docid": "gui/extensions/player/player.js", "score": 574.2017211914062}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/Preview.java", "score": 559.9503784179688}, {"docid": "applications/osmo4_android_studio/app/src/main/assets/configuration.xml", "score": 529.1635131835938}, {"docid": "gui/extensions/widget_manager/init.js", "score": 504.0267028808594}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/GPACInstance.java", "score": 451.86590576171875}, {"docid": "gui/webvtt-renderer.js", "score": 420.1242980957031}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/MPEGVSensor.java", "score": 404.5249938964844}, {"docid": "gui/tv_wm_gui.js", "score": 384.39630126953125}, {"docid": "gui/extensions/player/stats.js", "score": 381.3196105957031}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/extra/ConfigFileEditor.java", "score": 360.5758056640625}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/SensorServices.java", "score": 348.4985046386719}, {"docid": "gui/extensions/H2B2VS/h2b2vs.js", "score": 340.9187927246094}], "function_summary": "This code snippet is part of a box parsing function for ISO Media File Format (ISOBMFF) files. It handles the initial parsing of box headers from a bitstream.\n\n**Key functionality:**\n1. **Parameter validation** - Checks for valid bitstream and output parameters, ensures sufficient data is available\n2. **Box header parsing** - Reads the standard 8-byte box header (4-byte size + 4-byte type)\n3. **Special case handling** - Handles legacy QuickTime boxes with small sizes (2-4 bytes) by converting them to VOID boxes\n4. **Zero-size box handling** - For boxes with size 0, treats them as extending to end-of-file if at root level, otherwise skips them\n5. **UUID box processing** - For UUID boxes, reads the additional 16-byte UUID identifier and resolves it to an internal type\n6. **Large box support** - Handles 64-bit extended sizes when the initial size field is 1\n7. **Box creation** - Creates appropriate box objects based on parent context:\n   - Track reference boxes (TREF) \u2192 REFT boxes\n   - Item reference boxes (IREF) \u2192 REFI boxes  \n   - Track group boxes (TRGR) \u2192 TRGT boxes\n   - Group list boxes (GRPL) \u2192 GRPT boxes\n   - Default case uses factory method with resolved type\n\nThe code ensures robust parsing of various box formats while maintaining backward compatibility with legacy file formats."}
{"instance_id": "Choser_CVE-2018-18088", "hits": [{"docid": "wrapping/java/openjp2/java-sources/org/openJpeg/OpenJPEGJavaEncoder.java", "score": 1691.376953125}, {"docid": "wrapping/java/openjp2/java-sources/org/openJpeg/OpenJPEGJavaDecoder.java", "score": 1349.10205078125}, {"docid": "src/bin/jpip/opj_viewer/src/PnmImage.java", "score": 1289.6683349609375}, {"docid": "src/bin/jpip/opj_viewer/src/ImgdecClient.java", "score": 1043.7158203125}, {"docid": "src/bin/jpip/opj_viewer/src/ImageViewer.java", "score": 948.1478881835938}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/ImageViewer.java", "score": 948.1478881835938}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/JP2XMLparser.java", "score": 810.5584716796875}, {"docid": "src/bin/jpip/opj_viewer/src/JPIPHttpClient.java", "score": 713.5302734375}, {"docid": "src/bin/jpip/opj_viewer/src/RegimViewer.java", "score": 711.7274780273438}, {"docid": "src/bin/jpip/opj_viewer/src/ImageWindow.java", "score": 502.25469970703125}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/ImageWindow.java", "score": 502.25469970703125}, {"docid": "src/bin/jpip/opj_viewer/src/ImageManager.java", "score": 478.0675048828125}, {"docid": "src/bin/wx/OPJViewer/about/about.htm", "score": 423.9460144042969}, {"docid": "src/bin/jpip/opj_viewer/src/MML.java", "score": 295.3735046386719}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/OptionPanel.java", "score": 203.49819946289062}, {"docid": "tools/abi-tracker/openjpeg.json", "score": 94.15080261230469}, {"docid": "appveyor.yml", "score": 64.74099731445312}, {"docid": "src/bin/jpip/opj_viewer/src/ResizeListener.java", "score": 61.744598388671875}], "function_summary": "This code snippet is part of a PNM (Portable Network Graphics) image format output function that handles pixel value adjustment and writing for grayscale or single-component images.\n\n**Key functionality:**\n\n1. **Data preparation**: Gets a pointer to the image component data (`red`) and calculates an adjustment value (`adjustR`) based on whether the component uses signed values\n2. **Signed value adjustment**: If the component is signed (`sgnd` flag), it calculates a bias adjustment of `1 << (prec - 1)` to convert from signed to unsigned representation\n3. **High precision processing**: For components with precision greater than 8 bits (`prec > 8`), it processes each pixel by:\n   - Adding the adjustment value to handle signed/unsigned conversion\n   - The adjusted value `v` is then ready for output (likely as 16-bit data based on the precision check)\n\n**Purpose**: This is part of converting OpenJPEG's internal image representation to PNM format, specifically handling the mathematical transformation needed when component data uses signed integers but the output format expects unsigned values. The adjustment ensures proper value range mapping for different bit depths while preserving image fidelity.\n\nThe snippet represents the setup phase before actual pixel data writing to the output file."}
{"instance_id": "Choser_CVE-2018-5727", "hits": [{"docid": "wrapping/java/openjp2/java-sources/org/openJpeg/OpenJPEGJavaEncoder.java", "score": 684.1599731445312}, {"docid": "src/bin/jpip/opj_viewer/src/PnmImage.java", "score": 661.18017578125}, {"docid": "src/bin/jpip/opj_viewer/src/ImageViewer.java", "score": 482.7702941894531}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/ImageViewer.java", "score": 482.7702941894531}, {"docid": "wrapping/java/openjp2/java-sources/org/openJpeg/OpenJPEGJavaDecoder.java", "score": 469.79840087890625}, {"docid": "src/bin/jpip/opj_viewer/src/RegimViewer.java", "score": 437.54168701171875}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/JP2XMLparser.java", "score": 432.94580078125}, {"docid": "src/bin/jpip/opj_viewer/src/ImgdecClient.java", "score": 411.168212890625}, {"docid": "src/bin/jpip/opj_viewer/src/JPIPHttpClient.java", "score": 319.2745056152344}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/ImageWindow.java", "score": 219.66709899902344}, {"docid": "src/bin/jpip/opj_viewer/src/ImageWindow.java", "score": 219.6623992919922}, {"docid": "src/bin/jpip/opj_viewer/src/MML.java", "score": 211.27340698242188}, {"docid": "src/bin/jpip/opj_viewer/src/ImageManager.java", "score": 202.06910705566406}, {"docid": "appveyor.yml", "score": 168.99420166015625}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/OptionPanel.java", "score": 88.3511962890625}, {"docid": "src/bin/wx/OPJViewer/about/about.htm", "score": 81.30999755859375}, {"docid": "src/bin/jpip/opj_viewer/src/ResizeListener.java", "score": 64.46859741210938}, {"docid": "tools/abi-tracker/openjpeg.json", "score": 30.064800262451172}], "function_summary": "This code snippet is part of a JPEG2000 encoder's Tier-1 coding process, specifically handling the preparation of codeblock data before encoding. The code performs quantization preprocessing on wavelet coefficient data.\n\nThe functionality branches based on the quantization method type (`tccp->qmfbid`):\n\n1. **For lossless/reversible quantization** (`qmfbid == 1`): The code performs a simple bit-shift operation by multiplying each coefficient by `(1 << T1_NMSEDEC_FRACBITS)`, which scales the values to account for fractional bits used in the encoding process.\n\n2. **For lossy/irreversible quantization** (`qmfbid == 0`): The code applies a more complex fixed-point multiplication using `opj_int_fix_mul_t1()` with a band-specific constant (`bandconst`), which implements the quantization step size scaling.\n\nThe operations iterate through a 2D codeblock of dimensions `cblk_w` \u00d7 `cblk_h`, processing each coefficient in the `tiledp` array. The `tileIndex` is incremented for each coefficient and adjusted by `tileLineAdvance` at the end of each row to account for the tile's stride.\n\nThis preprocessing ensures that the wavelet coefficients are properly scaled according to the JPEG2000 standard before they undergo the arithmetic coding stage of the Tier-1 encoder."}
{"instance_id": "Choser_CVE-2018-5785", "hits": [{"docid": "src/bin/jpip/opj_viewer/src/PnmImage.java", "score": 1018.8001708984375}, {"docid": "src/bin/jpip/opj_viewer/src/ImgdecClient.java", "score": 888.4263916015625}, {"docid": "wrapping/java/openjp2/java-sources/org/openJpeg/OpenJPEGJavaDecoder.java", "score": 779.3685913085938}, {"docid": "wrapping/java/openjp2/java-sources/org/openJpeg/OpenJPEGJavaEncoder.java", "score": 716.5714721679688}, {"docid": "src/bin/jpip/opj_viewer/src/JPIPHttpClient.java", "score": 570.851318359375}, {"docid": "src/bin/jpip/opj_viewer/src/ImageViewer.java", "score": 564.8909301757812}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/ImageViewer.java", "score": 564.8909301757812}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/JP2XMLparser.java", "score": 383.76739501953125}, {"docid": "src/bin/jpip/opj_viewer/src/RegimViewer.java", "score": 293.26361083984375}, {"docid": "src/bin/wx/OPJViewer/about/about.htm", "score": 291.80029296875}, {"docid": "src/bin/jpip/opj_viewer/src/MML.java", "score": 218.88369750976562}, {"docid": "src/bin/jpip/opj_viewer/src/ImageManager.java", "score": 203.5316925048828}, {"docid": "src/bin/jpip/opj_viewer/src/ImageWindow.java", "score": 162.1562957763672}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/ImageWindow.java", "score": 162.1562957763672}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/OptionPanel.java", "score": 119.3042984008789}, {"docid": "tools/abi-tracker/openjpeg.json", "score": 64.53389739990234}, {"docid": "src/bin/jpip/opj_viewer/src/ResizeListener.java", "score": 48.17110061645508}, {"docid": "appveyor.yml", "score": 32.54209899902344}], "function_summary": "This code snippet is part of a BMP (bitmap) file header parsing function that reads color mask and color space information from a BMP file's info header. \n\nThe snippet performs the following operations:\n\n1. **Reads color channel masks**: It reads 4-byte values for green, blue, and alpha channel bit masks from the input file stream using `getc()`. Each mask is constructed by reading 4 bytes and combining them using bitwise OR operations with appropriate bit shifts to form 32-bit values.\n\n2. **Reads color space information**: For BMP headers with size \u2265 108 bytes (BITMAPV4HEADER), it reads:\n   - Color space type (4 bytes)\n   - Color space endpoints (36 bytes) using `fread()`\n   \n3. **Error handling**: The code includes error checking for the `fread()` operation, printing an error message and returning `OPJ_FALSE` if the read operation fails.\n\nThis is part of the BMP to OpenJPEG image conversion functionality, where these color masks and color space parameters are essential for properly interpreting pixel data in BMP files that use bit masking for color channels (typically 16-bit and 32-bit BMP formats). The masks define which bits in each pixel correspond to specific color channels."}
{"instance_id": "Choser_CVE-2018-6616", "hits": [{"docid": "src/bin/jpip/opj_viewer/src/PnmImage.java", "score": 1016.470703125}, {"docid": "src/bin/jpip/opj_viewer/src/ImgdecClient.java", "score": 889.769287109375}, {"docid": "wrapping/java/openjp2/java-sources/org/openJpeg/OpenJPEGJavaDecoder.java", "score": 770.434814453125}, {"docid": "wrapping/java/openjp2/java-sources/org/openJpeg/OpenJPEGJavaEncoder.java", "score": 725.447021484375}, {"docid": "src/bin/jpip/opj_viewer/src/JPIPHttpClient.java", "score": 569.57958984375}, {"docid": "src/bin/jpip/opj_viewer/src/ImageViewer.java", "score": 562.22509765625}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/ImageViewer.java", "score": 562.22509765625}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/JP2XMLparser.java", "score": 387.78021240234375}, {"docid": "src/bin/jpip/opj_viewer/src/RegimViewer.java", "score": 291.88079833984375}, {"docid": "src/bin/wx/OPJViewer/about/about.htm", "score": 278.44061279296875}, {"docid": "src/bin/jpip/opj_viewer/src/MML.java", "score": 222.43670654296875}, {"docid": "src/bin/jpip/opj_viewer/src/ImageManager.java", "score": 202.0948944091797}, {"docid": "src/bin/jpip/opj_viewer/src/ImageWindow.java", "score": 160.3675994873047}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/ImageWindow.java", "score": 160.3675994873047}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/OptionPanel.java", "score": 117.29889678955078}, {"docid": "tools/abi-tracker/openjpeg.json", "score": 70.89990234375}, {"docid": "src/bin/jpip/opj_viewer/src/ResizeListener.java", "score": 48.52159881591797}, {"docid": "appveyor.yml", "score": 29.665800094604492}], "function_summary": "This code snippet implements the `bmp_read_rle8_data` function, which decodes RLE8 (Run-Length Encoded 8-bit) compressed BMP image data from a file stream.\n\nThe function reads compressed bitmap data and decompresses it into a pixel buffer. It processes the RLE8 format through a state machine that handles different command codes:\n\n- **Encoded runs**: When a non-zero count is read, it's followed by a color value that gets repeated for the specified count\n- **Escape sequences** (when count is 0):\n  - `0x00`: End of line - moves to the next scanline\n  - `0x01`: End of picture - terminates decoding\n  - `0x02`: Delta move - reads dx,dy offsets to reposition the pixel pointer\n  - `0x03-0xFF`: Absolute mode - reads the specified number of literal pixel values, with padding to maintain word alignment\n\nThe function maintains bounds checking to prevent buffer overflows, tracks the current position (x,y coordinates), and handles EOF conditions gracefully. It returns `OPJ_TRUE` on successful decompression or `OPJ_FALSE` on errors.\n\nThis is part of OpenJPEG's BMP format support, specifically handling the RLE8 compression variant commonly used in Windows bitmap files."}
{"instance_id": "Choser_CVE-2020-24829", "hits": [{"docid": "doc/configuration.html", "score": 3314.751708984375}, {"docid": "applications/osmo4_android_studio/app/src/main/assets/configuration.xml", "score": 1992.6864013671875}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/GpacCallback.java", "score": 1826.3155517578125}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/Osmo4.java", "score": 1613.2911376953125}, {"docid": "gui/iphone_wm_gui.js", "score": 1491.43603515625}, {"docid": "gui/extensions/player/player.js", "score": 1485.5621337890625}, {"docid": "gui/mpegu-core.js", "score": 1359.662841796875}, {"docid": "gui/mpegu-wm.js", "score": 1300.4014892578125}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/GPACInstance.java", "score": 1151.4696044921875}, {"docid": "gui/gui_old.js", "score": 1139.700439453125}, {"docid": "gui/extensions/widget_manager/init.js", "score": 1013.3353881835938}, {"docid": "gui/extensions/player/stats.js", "score": 1001.2332763671875}, {"docid": "applications/osmo4_android_studio/app/src/main/res/values/strings.xml", "score": 988.1868286132812}, {"docid": "gui/webvtt-renderer.js", "score": 972.4108276367188}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/GpacConfig.java", "score": 968.0313110351562}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/Preview.java", "score": 893.0194702148438}, {"docid": "applications/mp4box_android/src/com/enst/mp4box/mp4box.java", "score": 826.6796264648438}, {"docid": "gui/gwlib.js", "score": 803.9468994140625}, {"docid": "gui/tv_wm_gui.js", "score": 659.969970703125}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/SensorServices.java", "score": 638.3272705078125}], "function_summary": "This code snippet configures a DASH (Dynamic Adaptive Streaming over HTTP) segmenter for creating adaptive streaming content. It performs the following key operations:\n\n1. **Error Handling**: Checks if the dasher object was successfully created, and if not, returns an error code.\n\n2. **Basic Configuration**: Sets up DASH metadata including title, copyright, description, and source information using `gf_dasher_set_info()`.\n\n3. **URL and Timeline Setup**: \n   - Adds base URLs for the manifest\n   - Handles segment timeline configuration, automatically enabling URL templates when segment timeline is used\n   - Configures URL templates, segment extensions, and naming\n\n4. **DASH Parameters**: Configures multiple DASH-specific settings through a series of conditional function calls:\n   - Segment and fragment durations\n   - RAP (Random Access Point) splitting options\n   - Single segment/file modes\n   - Bitstream switching modes\n   - SIDX (Segment Index) boxes configuration\n   - Dynamic mode settings (live streaming)\n   - Buffer management and timing offsets\n\n5. **Input Processing**: Adds all input files to the dasher for processing.\n\n6. **Error Management**: Each configuration step checks for errors and stops processing if any configuration fails.\n\nThe code uses a pattern of conditional error checking (`if (!e)`) to ensure each step completes successfully before proceeding to the next configuration step."}
{"instance_id": "Choser_CVE-2020-27814", "hits": [{"docid": "wrapping/java/openjp2/java-sources/org/openJpeg/OpenJPEGJavaEncoder.java", "score": 1149.0003662109375}, {"docid": "src/bin/jpip/opj_viewer/src/PnmImage.java", "score": 643.1478881835938}, {"docid": "wrapping/java/openjp2/java-sources/org/openJpeg/OpenJPEGJavaDecoder.java", "score": 577.9030151367188}, {"docid": "src/bin/jpip/opj_viewer/src/ImageViewer.java", "score": 514.7595825195312}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/ImageViewer.java", "score": 514.7595825195312}, {"docid": "src/bin/jpip/opj_viewer/src/ImgdecClient.java", "score": 472.9845886230469}, {"docid": "src/bin/jpip/opj_viewer/src/JPIPHttpClient.java", "score": 426.408203125}, {"docid": "src/bin/jpip/opj_viewer/src/MML.java", "score": 362.88848876953125}, {"docid": "src/bin/jpip/opj_viewer/src/RegimViewer.java", "score": 332.9248046875}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/JP2XMLparser.java", "score": 272.48919677734375}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/ImageWindow.java", "score": 241.08059692382812}, {"docid": "src/bin/jpip/opj_viewer/src/ImageWindow.java", "score": 241.0760040283203}, {"docid": "src/bin/jpip/opj_viewer/src/ImageManager.java", "score": 239.7991943359375}, {"docid": "src/bin/wx/OPJViewer/about/about.htm", "score": 221.64480590820312}, {"docid": "src/bin/jpip/opj_viewer_xerces/src/OptionPanel.java", "score": 125.32730102539062}, {"docid": "src/bin/jpip/opj_viewer/src/ResizeListener.java", "score": 59.702598571777344}, {"docid": "appveyor.yml", "score": 44.315101623535156}, {"docid": "tools/abi-tracker/openjpeg.json", "score": 38.0}], "function_summary": "This code snippet is from the `opj_tcd_code_block_enc_allocate_data` function in OpenJPEG's tile component decoder (TCD) module. The main functionality is to allocate data memory for an encoding code block.\n\n**Key operations:**\n\n1. **Size calculation**: Calculates the required data size for a code block by computing its dimensions `(x1-x0) * (y1-y0)`, multiplying by `sizeof(OPJ_UINT32)`, and adding a safety margin of 2 bytes. The comments reference GitHub issues indicating this extra padding is needed to prevent buffer overflows.\n\n2. **Memory allocation decision**: Checks if the calculated size exceeds the currently allocated buffer size (`p_code_block->data_size`). \n\n3. **Conditional reallocation**: If more memory is needed, the function will proceed to free the existing buffer and allocate a new one with the required size.\n\nThe snippet includes a TODO comment questioning whether there's a theoretical upper bound for compressed code block size, suggesting this is part of a dynamic memory management system that grows buffers as needed. This is typical in JPEG 2000 encoding where code block sizes can vary significantly depending on image content and compression parameters."}
{"instance_id": "Choser_CVE-2021-29279", "hits": [{"docid": "share/deprecated/mpegu-core.js", "score": 1165.9434814453125}, {"docid": "share/python/libgpac.py", "score": 1052.069580078125}, {"docid": "share/vis/Code/TimelineRow.js", "score": 754.1119995117188}, {"docid": "share/scripts/jsf/avgen/init.js", "score": 679.7733764648438}, {"docid": "share/scripts/vout.js", "score": 598.7183837890625}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/GpacCallback.java", "score": 383.70941162109375}, {"docid": "share/gui/extensions/player/player.js", "score": 381.49530029296875}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/Osmo4.java", "score": 360.1886901855469}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/Preview.java", "score": 343.180908203125}, {"docid": "applications/osmo4_android_studio/app/src/main/assets/configuration.xml", "score": 339.55169677734375}, {"docid": "share/gui/gwlib.js", "score": 322.66900634765625}, {"docid": "share/deprecated/iphone_wm_gui.js", "score": 320.6736145019531}, {"docid": "share/deprecated/mpegu-wm.js", "score": 316.5860900878906}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/MPEGVSensor.java", "score": 308.2080078125}, {"docid": "share/scripts/ttml-renderer.js", "score": 283.08538818359375}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/SensorServices.java", "score": 280.3960876464844}, {"docid": "share/gui/extensions/player/stats.js", "score": 248.81590270996094}, {"docid": "share/gui/extensions/widget_manager/init.js", "score": 244.81590270996094}, {"docid": "share/deprecated/tv_wm_gui.js", "score": 244.23410034179688}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/GPACInstance.java", "score": 235.50230407714844}], "function_summary": "This code snippet is part of the main packet processing function (`flac_dmx_process`) in a FLAC reframer filter. The functionality includes:\n\n**Main Operations:**\n1. **Duration parsing** - Continuously reparses file duration if not yet determined\n2. **Packet retrieval** - Gets input packets from the filter pipeline, handling end-of-stream conditions\n3. **Buffer management** - Accumulates incoming packet data into an internal FLAC buffer, reallocating as needed\n4. **Byte offset tracking** - Maintains position tracking for seeking operations\n5. **Frame synchronization** - Searches for FLAC frame headers (0xFF sync patterns) in the buffered data\n\n**Key Logic:**\n- **Initialization handling** - On first run, parses the FLAC file header and metadata blocks to extract audio properties (sample rate, channels, bit depth, duration)\n- **Frame validation** - Verifies frame synchronization markers and drops invalid data\n- **Resume capability** - Supports resuming from specific buffer positions during seeking\n- **Stream configuration** - Sets up output PID properties based on parsed FLAC metadata\n\nThe code efficiently handles streaming FLAC data by buffering incomplete frames until enough data is available for proper parsing and frame boundary detection. It's designed to work with both file-based and streaming inputs while maintaining synchronization and proper timing information."}
{"instance_id": "Choser_CVE-2023-0770", "hits": [{"docid": "applications/deprecated/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/GpacCallback.java", "score": 1768.84619140625}, {"docid": "share/python/libgpac/libgpac.py", "score": 1543.9200439453125}, {"docid": "share/scripts/jsf/avmix/init.js", "score": 1472.837890625}, {"docid": "share/scripts/jsf/avmix/help.js", "score": 1314.166259765625}, {"docid": "applications/deprecated/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/Osmo4.java", "score": 1267.76171875}, {"docid": "share/deprecated/iphone_wm_gui.js", "score": 1154.1092529296875}, {"docid": "applications/gpac_android/src/main/java/io/gpac/gpac/GPAC.java", "score": 1135.1326904296875}, {"docid": "share/deprecated/mpegu-core.js", "score": 1000.4058837890625}, {"docid": "share/scripts/jsf/avmix/scenes/shape.js", "score": 994.3668823242188}, {"docid": "share/vis/extern/BrowserLib/Core/Code/DOM.js", "score": 993.8626708984375}, {"docid": "share/scripts/vout.js", "score": 983.531982421875}, {"docid": "share/gui/extensions/player/player.js", "score": 957.8076782226562}, {"docid": "share/vis/extern/BrowserLib/WindowManager/Code/Grid.js", "score": 936.2139282226562}, {"docid": "share/scripts/jsf/thumbs/init.js", "score": 932.9259033203125}, {"docid": "share/scripts/ttml-renderer.js", "score": 912.8184204101562}, {"docid": "share/vis/Code/TimelineRow.js", "score": 892.049072265625}, {"docid": "share/deprecated/mpegu-wm.js", "score": 889.3250122070312}, {"docid": "share/gui/gwlib.js", "score": 881.076171875}, {"docid": "share/scripts/jsf/avgen/init.js", "score": 873.9852294921875}, {"docid": "applications/deprecated/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/SensorServices.java", "score": 821.40869140625}], "function_summary": "This code snippet is part of a function that determines whether a VRML/X3D proto field represents an SFTime offset field. \n\nThe main functionality checks if a proto field should have its time value offset when the scene graph is cloned. It does this by:\n\n1. **Recursive Proto Check**: If the field is connected (via an IS route) to another proto node, it recursively calls itself to check that proto's field.\n\n2. **Time Field Detection**: If the field is connected to a regular node field, it checks if that field is named \"startTime\" or \"stopTime\" using case-insensitive string comparison.\n\n3. **Return Logic**: Returns `true` (1) if the field is connected to a startTime/stopTime field, indicating it should be time-offset during cloning operations. Returns `false` (0) otherwise.\n\nThis is part of GPAC's scene graph system for handling VRML/X3D proto instantiation. The function ensures that when proto instances are cloned, time-related fields like startTime and stopTime are properly adjusted relative to the current scene time, which is crucial for maintaining correct timing behavior in animated content when proto instances are created dynamically."}
{"instance_id": "Choser_CVE-2023-4754", "hits": [{"docid": "share/python/libgpac/libgpac.py", "score": 3361.661865234375}, {"docid": "share/emscripten/gpac.html", "score": 3223.064208984375}, {"docid": "applications/gpac_android/src/main/java/io/gpac/gpac/GPAC.java", "score": 2882.137451171875}, {"docid": "share/scripts/jsf/avmix/help.js", "score": 2873.255615234375}, {"docid": "share/scripts/jsf/avmix/init.js", "score": 2570.99267578125}, {"docid": "share/gui/gwlib.js", "score": 2273.576904296875}, {"docid": "share/scripts/jsf/uncvg.js", "score": 2115.634521484375}, {"docid": "share/scripts/jsf/avmix/scenes/shape.js", "score": 1894.8056640625}, {"docid": "share/scripts/jsf/avgen/init.js", "score": 1768.3255615234375}, {"docid": "share/deprecated/iphone_wm_gui.js", "score": 1642.9119873046875}, {"docid": "share/deprecated/mpegu-wm.js", "score": 1571.62109375}, {"docid": "share/scripts/jsf/thumbs/init.js", "score": 1509.8858642578125}, {"docid": "share/vis/Code/Remotery.js", "score": 1496.788818359375}, {"docid": "share/scripts/vout.js", "score": 1444.015625}, {"docid": "share/gui/extensions/player/player.js", "score": 1415.852294921875}, {"docid": "share/deprecated/mpegu-core.js", "score": 1338.037353515625}, {"docid": "share/gui/extensions/widget_manager/init.js", "score": 1254.2659912109375}, {"docid": "share/vis/Code/DataViewReader.js", "score": 1238.5850830078125}, {"docid": "applications/gpac_android/src/main/java/io/gpac/gpac/extra/FileChooserFragment.java", "score": 1237.9183349609375}, {"docid": "applications/gpac_android/src/main/java/io/gpac/gpac/SensorServices.java", "score": 1220.8238525390625}], "function_summary": "This code snippet is part of a SWF (Flash) font definition parser that handles two different font format revisions (0 and 1). \n\nFor **revision 0** (older format):\n- Reads the starting file position and a count value\n- Calculates the number of glyphs as count/2\n- Creates an offset table to store glyph positions, reading 16-bit offsets for each glyph\n- Iterates through each glyph, seeking to its position and parsing its shape definition\n\nFor **revision 1** (newer format):\n- Reads various font flags (layout, character encoding, styling)\n- Extracts font metadata including name length and font name characters\n- Reads the total number of glyphs\n- Creates an offset table with either 32-bit or 16-bit offsets depending on the `wide_offset` flag\n\nThe key functionality is building an offset table that maps each glyph to its location in the file, enabling efficient random access to glyph shape data. The code handles memory allocation for the offset table and adapts to different data widths based on font format capabilities. This is essential for SWF font rendering, as it allows the parser to locate and extract individual character shapes from the compressed font data."}
{"instance_id": "Choser_CVE-2023-4756", "hits": [{"docid": "share/emscripten/gpac.html", "score": 4108.8251953125}, {"docid": "share/python/libgpac/libgpac.py", "score": 3324.676513671875}, {"docid": "share/scripts/jsf/avmix/help.js", "score": 3304.086669921875}, {"docid": "share/scripts/jsf/avmix/init.js", "score": 2958.90771484375}, {"docid": "share/scripts/vout.js", "score": 2460.459228515625}, {"docid": "share/gui/extensions/player/player.js", "score": 2406.075927734375}, {"docid": "share/scripts/jsf/uncvg.js", "score": 2292.320068359375}, {"docid": "share/gui/gwlib.js", "score": 2043.8167724609375}, {"docid": "share/scripts/jsf/avmix/scenes/shape.js", "score": 2024.057373046875}, {"docid": "applications/gpac_android/src/main/java/io/gpac/gpac/GPAC.java", "score": 1950.9525146484375}, {"docid": "share/deprecated/mpegu-core.js", "score": 1905.322509765625}, {"docid": "share/deprecated/iphone_wm_gui.js", "score": 1854.0283203125}, {"docid": "share/deprecated/mpegu-wm.js", "score": 1732.857421875}, {"docid": "share/scripts/jsf/avgen/init.js", "score": 1628.392333984375}, {"docid": "share/gui/extensions/H2B2VS/h2b2vs.js", "score": 1530.38330078125}, {"docid": "share/scripts/jsf/thumbs/init.js", "score": 1466.9271240234375}, {"docid": "share/gui/extensions/widget_manager/init.js", "score": 1456.5926513671875}, {"docid": "share/gui/gui.js", "score": 1265.2464599609375}, {"docid": "share/vis/extern/BrowserLib/Core/Code/Convert.js", "score": 1264.76220703125}, {"docid": "share/gui/extensions/player/stats.js", "score": 1242.414306640625}], "function_summary": "This code snippet is from the `gf_bt_check_line` function in a BT (Binary Format for Scenes) parser for the GPAC multimedia framework. The function's main purpose is to skip whitespace characters and handle comment detection in the input stream.\n\n**Key functionality:**\n\n1. **Whitespace skipping**: The function iterates through the current line buffer, advancing the position pointer (`line_pos`) past any whitespace characters (spaces, tabs, newlines, carriage returns).\n\n2. **Comment detection**: After skipping whitespace, it checks for two types of comments:\n   - Single-line comments starting with `#`\n   - C++-style comments starting with `//`\n\n3. **Line truncation**: When a comment is detected, it effectively truncates the line by setting `line_size` to the current position, treating everything after the comment marker as ignored content.\n\n4. **End-of-input handling**: If the parser reaches the end of the current line content (when `line_size == line_pos`), it checks if this is string-based input. If so, and there's no gzipped file input stream (`gz_in`), it marks parsing as complete by setting `parser->done = 1`.\n\nThis function is essential for proper parsing of BT format files by ensuring the parser correctly handles formatting and comments while processing scene description data."}
{"instance_id": "Choser_CVE-2024-0321", "hits": [{"docid": "share/scripts/jsf/avmix/init.js", "score": 4721.583984375}, {"docid": "share/deprecated/mpegu-core.js", "score": 3822.097412109375}, {"docid": "share/python/libgpac/libgpac.py", "score": 2989.377197265625}, {"docid": "share/emscripten/gpac.html", "score": 2684.473388671875}, {"docid": "share/scripts/jsf/uncvg.js", "score": 2639.6796875}, {"docid": "share/scripts/jsf/thumbs/init.js", "score": 2439.024169921875}, {"docid": "share/vis/Code/TimelineRow.js", "score": 2413.577880859375}, {"docid": "share/scripts/ttml-renderer.js", "score": 2352.02197265625}, {"docid": "share/scripts/jsf/avmix/scenes/shape.js", "score": 2334.705078125}, {"docid": "share/scripts/vout.js", "score": 2326.13134765625}, {"docid": "share/scripts/jsf/avgen/init.js", "score": 2272.25341796875}, {"docid": "share/gui/extensions/player/player.js", "score": 2260.656005859375}, {"docid": "share/scripts/jsf/avmix/help.js", "score": 2079.83056640625}, {"docid": "share/gui/gwlib.js", "score": 2068.82763671875}, {"docid": "share/deprecated/mpegu-wm.js", "score": 1940.6727294921875}, {"docid": "share/deprecated/iphone_wm_gui.js", "score": 1924.3179931640625}, {"docid": "applications/gpac_android/src/main/java/io/gpac/gpac/GPAC.java", "score": 1913.7750244140625}, {"docid": "share/scripts/webvtt-renderer.js", "score": 1563.6099853515625}, {"docid": "share/gui/extensions/widget_manager/init.js", "score": 1521.05224609375}, {"docid": "share/vis/extern/BrowserLib/Core/Code/Keyboard.js", "score": 1376.3818359375}], "function_summary": "This code snippet is part of a UTF-8 text line conversion function in the GPAC multimedia framework's text import filter. The main functionality includes:\n\n1. **UTF-8 Conversion Loop**: The code processes characters from an input line (`szLine`) and converts them to proper UTF-8 format, storing the result in `szLineConv`.\n\n2. **Non-UTF8 Character Handling**: It detects non-UTF-8 characters (when `szLine[i] & 0x80` is true) and handles various UTF-8 encoding scenarios:\n   - Single-byte non-UTF8 characters are converted to 2-byte UTF-8 sequences\n   - Existing 2-byte, 3-byte, and 4-byte UTF-8 sequences are preserved\n   - Invalid sequences are skipped\n\n3. **Buffer Management**: The function includes bounds checking to prevent buffer overflow (`j >= GF_ARRAY_LENGTH(szLineConv)`) and logs warnings if lines are too long to convert.\n\n4. **Endianness Handling**: The snippet ends with a big-endian preprocessor check, indicating platform-specific byte order handling for UTF-16 processing.\n\nThe function essentially ensures that text input is properly converted to UTF-8 format while handling various encoding edge cases and maintaining data integrity during the conversion process."}
{"instance_id": "krrrlww_CVE-2019-15903", "hits": [{"docid": "expat/doc/reference.html", "score": 1492.2340087890625}, {"docid": "expat/doc/xmlwf.xml", "score": 239.2292022705078}, {"docid": "appveyor.yml", "score": 115.3949966430664}], "function_summary": "This code snippet contains several key XML parsing processor functions from the Expat XML parser library:\n\n## Main Functions:\n\n1. **`entityValueProcessor`** - Processes entity values in DTD declarations by tokenizing the content and storing it when the end is reached.\n\n2. **`prologProcessor`** - Handles XML prolog parsing by calling `doProlog` with the current encoding and token information.\n\n3. **`doProlog`** - The core DTD and prolog processing function that handles a comprehensive switch statement for different XML roles including:\n   - XML declarations and DOCTYPE declarations\n   - Entity declarations (general and parameter entities)\n   - Attribute list declarations\n   - Element declarations and content models\n   - Notation declarations\n   - Processing instructions and comments\n\n4. **`processInternalEntity`** - Manages internal entity expansion by setting up entity context and recursively calling appropriate processors.\n\n5. **`internalEntityProcessor`** - Continues processing internal entities that were suspended, handling both parameter entities (DTD context) and general entities (content context).\n\nThe code implements a state machine approach where different processors handle different parsing contexts. It manages complex XML features like entity references, DTD validation, namespace processing, and maintains proper parsing state throughout the process. Error handling is integrated throughout with specific XML error codes returned for various parsing failures."}
{"instance_id": "krrrlww_CVE-2024-28757", "hits": [{"docid": "expat/doc/reference.html", "score": 1892.2762451171875}, {"docid": "testdata/largefiles/nes96.xml", "score": 573.477294921875}, {"docid": "expat/doc/xmlwf.xml", "score": 382.875}, {"docid": "expat/xmlwf/xmlwf_helpgen.py", "score": 255.13710021972656}, {"docid": "appveyor.yml", "score": 187.9290008544922}, {"docid": "testdata/largefiles/aaaaaa_attr.xml", "score": 1.5628999471664429}, {"docid": "testdata/largefiles/aaaaaa_text.xml", "score": 0.5320000052452087}], "function_summary": "This code snippet implements a function called `accountingGetCurrentAmplification` that calculates the amplification factor for XML parsing operations in the Expat XML parser library.\n\n**Main functionality:**\n\n1. **Calculates total output bytes** by summing direct bytes (`countBytesDirect`) and indirect bytes (`countBytesIndirect`) from the parser's accounting structure.\n\n2. **Computes amplification factor** as the ratio of total output bytes to direct input bytes:\n   - If there are direct bytes: `amplificationFactor = totalOutput / directBytes`\n   - If no direct bytes: defaults to `1.0f` (no amplification)\n\n3. **Safety check** using an assertion to verify the parser is a root parser (has no parent).\n\n**Purpose:**\nThis function is part of Expat's billion laughs attack protection mechanism. XML entity expansion can cause significant memory amplification where small input can generate massive output through recursive entity references. By tracking the amplification factor (how much the output has grown relative to the direct input), the parser can detect and prevent such attacks by limiting excessive memory usage during XML processing.\n\nThe function returns the current amplification ratio as a float value, which can be used by the parser's security mechanisms to determine if processing should be halted."}
{"instance_id": "krrrlww_CVE-2019-20208", "hits": [{"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/MPEGVSensor.java", "score": 3937.7548828125}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/GpacCallback.java", "score": 2816.764404296875}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/Osmo4.java", "score": 2498.80078125}, {"docid": "gui/extensions/player/player.js", "score": 2191.470703125}, {"docid": "gui/iphone_wm_gui.js", "score": 2132.747314453125}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/GPACInstance.java", "score": 2083.3671875}, {"docid": "gui/gwlib.js", "score": 2014.9912109375}, {"docid": "gui/mpegu-wm.js", "score": 1984.05712890625}, {"docid": "gui/gui_old.js", "score": 1884.166015625}, {"docid": "applications/mp4box_android/src/com/enst/mp4box/mp4box.java", "score": 1829.898193359375}, {"docid": "gui/mpegu-core.js", "score": 1792.279296875}, {"docid": "doc/configuration.html", "score": 1739.283203125}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/GpacConfig.java", "score": 1696.7547607421875}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/Preview.java", "score": 1631.6121826171875}, {"docid": "gui/webvtt-renderer.js", "score": 1599.442626953125}, {"docid": "gui/extensions/player/stats.js", "score": 1575.1795654296875}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/logs/GpacLogger.java", "score": 1568.140869140625}, {"docid": "applications/osmo4_android_studio/app/src/main/assets/configuration.xml", "score": 1328.033447265625}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/SensorServices.java", "score": 1319.496337890625}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/extra/ConfigFileEditor.java", "score": 1193.5186767578125}], "function_summary": "This code snippet is part of a box writing function in the GPAC multimedia framework's ISO media file format implementation. It handles writing optional padding bits and sub-sample information to a bitstream.\n\nThe snippet performs two conditional write operations:\n\n1. **Padding Bits Writing**: If the `PaddingBits` field exists, it writes the padding bits box to the bitstream using `gf_isom_box_write()`. This handles cases where samples need specific bit padding information.\n\n2. **Sub-samples Writing**: If the `sub_samples` array exists, it writes all sub-sample information boxes to the bitstream using `gf_isom_box_array_write()`. Sub-samples represent subdivisions within media samples, commonly used for codecs that organize data hierarchically.\n\nBoth operations follow the same pattern: check for existence of the data structure, attempt to write it to the bitstream, and return any error that occurs during the write process. This is part of a larger sample table box writing function that serializes various optional metadata components for ISO media files (like MP4). The error handling ensures that any write failures are propagated up the call stack for proper error management."}
{"instance_id": "Choser_CVE-2018-9251", "hits": [{"docid": "doc/xml.html", "score": 2511.03076171875}, {"docid": "doc/libxml2-api.xml", "score": 2183.458984375}, {"docid": "doc/news.html", "score": 2060.507568359375}, {"docid": "genChRanges.py", "score": 2038.2691650390625}, {"docid": "gentest.py", "score": 1871.8580322265625}, {"docid": "doc/html/libxml-parser.html", "score": 1480.218505859375}, {"docid": "doc/devhelp/libxml2-parser.html", "score": 1471.308349609375}, {"docid": "doc/devhelp/libxml2-xmlreader.html", "score": 1466.8328857421875}, {"docid": "doc/html/libxml-xmlreader.html", "score": 1448.5606689453125}, {"docid": "doc/html/libxml-encoding.html", "score": 1411.6907958984375}, {"docid": "doc/devhelp/libxml2-encoding.html", "score": 1402.5782470703125}, {"docid": "doc/devhelp/libxml2-valid.html", "score": 1388.435546875}, {"docid": "doc/html/libxml-xmlregexp.html", "score": 1387.3746337890625}, {"docid": "doc/html/libxml-valid.html", "score": 1386.9896240234375}, {"docid": "doc/devhelp/libxml2-xmlregexp.html", "score": 1379.14453125}, {"docid": "doc/html/libxml-tree.html", "score": 1363.690673828125}, {"docid": "doc/devhelp/libxml2-tree.html", "score": 1358.749267578125}, {"docid": "result/valid/REC-xml-19980210.xml", "score": 1316.364501953125}, {"docid": "doc/xmlreader.html", "score": 1310.8050537109375}, {"docid": "doc/apibuild.py", "score": 1309.6029052734375}], "function_summary": "This code snippet is part of the decompression loop in the `xz_decomp` function. It handles the final steps after decompressing data from either LZMA or GZIP streams.\n\n**Key functionality:**\n\n1. **Loop termination**: The `while` loop continues decompressing until either the output buffer is full (`strm->avail_out == 0`) or the stream ends (`ret == LZMA_STREAM_END`).\n\n2. **Output buffer management**: After decompression, it calculates how much new data was produced by subtracting the remaining available output space from the original amount (`had - strm->avail_out`). This value is stored in `state->have`.\n\n3. **Pointer adjustment**: Sets `state->next` to point to the beginning of the newly decompressed data by moving back from the current output position.\n\n4. **CRC calculation**: When GZIP support is enabled, it updates the running CRC32 checksum (`state->zstrm.adler`) with the newly decompressed data to verify data integrity.\n\nThis snippet essentially finalizes each iteration of the decompression process by tracking how much data was produced and maintaining data integrity checks for GZIP streams."}
{"instance_id": "Choser_CVE-2020-23266", "hits": [{"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/MPEGVSensor.java", "score": 4059.261474609375}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/GpacCallback.java", "score": 2851.63427734375}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/Osmo4.java", "score": 2514.365966796875}, {"docid": "gui/extensions/player/player.js", "score": 2231.899658203125}, {"docid": "gui/iphone_wm_gui.js", "score": 2176.133544921875}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/GPACInstance.java", "score": 2120.58056640625}, {"docid": "gui/gwlib.js", "score": 2063.8115234375}, {"docid": "gui/mpegu-wm.js", "score": 2026.2030029296875}, {"docid": "gui/gui_old.js", "score": 1929.8658447265625}, {"docid": "applications/mp4box_android/src/com/enst/mp4box/mp4box.java", "score": 1858.12890625}, {"docid": "gui/mpegu-core.js", "score": 1831.396484375}, {"docid": "doc/configuration.html", "score": 1762.070068359375}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/GpacConfig.java", "score": 1715.2965087890625}, {"docid": "gui/webvtt-renderer.js", "score": 1670.734619140625}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/Preview.java", "score": 1639.2747802734375}, {"docid": "gui/extensions/player/stats.js", "score": 1631.3253173828125}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/logs/GpacLogger.java", "score": 1588.004638671875}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/SensorServices.java", "score": 1339.566162109375}, {"docid": "applications/osmo4_android_studio/app/src/main/assets/configuration.xml", "score": 1318.60302734375}, {"docid": "modules/widgetman/wgt_load_base.js", "score": 1227.469482421875}], "function_summary": "This code snippet contains functions for creating and reading an STBL (Sample Table Box) in the ISO Media File Format. Here's the main functionality:\n\n**stbl_Read() function (lines before the snippet):**\n- Reads and parses a sample table box from a bitstream\n- Uses `gf_isom_box_array_read()` to parse child boxes via the `stbl_AddBox` callback\n- Sets a flag (`no_sync_found`) if no sync sample box is present\n- Stores counts of sample group description boxes and other boxes for later reference\n- Validates that mandatory boxes are present (SampleToChunk, SampleSize, ChunkOffset, TimeToSample)\n- Returns an error if required boxes are missing\n\n**stbl_New() function:**\n- Creates and initializes a new Sample Table Box structure\n- Allocates memory for a `GF_SampleTableBox` with type `GF_ISOM_BOX_TYPE_STBL`\n- Sets default values including `MaxSamplePerChunk = 10` and `groupID = 1`\n- Returns the newly created box structure\n\nThe sample table box is a crucial component in MP4/ISO media files that contains metadata about media samples, including timing, size, location, and synchronization information. This code ensures proper initialization and validation of this critical data structure."}
{"instance_id": "Choser_CVE-2020-23267", "hits": [{"docid": "doc/configuration.html", "score": 1076.7298583984375}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/GpacCallback.java", "score": 875.9636840820312}, {"docid": "gui/webvtt-renderer.js", "score": 568.760986328125}, {"docid": "applications/osmo4_android_studio/app/src/main/assets/configuration.xml", "score": 531.197509765625}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/Osmo4.java", "score": 513.47021484375}, {"docid": "gui/iphone_wm_gui.js", "score": 512.9954833984375}, {"docid": "gui/extensions/player/player.js", "score": 494.26129150390625}, {"docid": "gui/mpegu-wm.js", "score": 463.5172119140625}, {"docid": "gui/extensions/player/stats.js", "score": 443.7572021484375}, {"docid": "gui/mpegu-core.js", "score": 440.3038024902344}, {"docid": "gui/gwlib.js", "score": 434.2059020996094}, {"docid": "gui/gui_old.js", "score": 425.96270751953125}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/Preview.java", "score": 395.1355895996094}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/GPACInstance.java", "score": 349.7633056640625}, {"docid": "gui/extensions/widget_manager/init.js", "score": 329.8951110839844}, {"docid": "gui/tv_wm_gui.js", "score": 288.848388671875}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/SensorServices.java", "score": 267.4693908691406}, {"docid": "gui/extensions/H2B2VS/h2b2vs.js", "score": 257.8005065917969}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/MPEGVSensor.java", "score": 243.49180603027344}, {"docid": "applications/osmo4_android_studio/app/src/main/java/com/gpac/Osmo4/extra/ConfigFileEditor.java", "score": 224.86419677734375}], "function_summary": "This code snippet is part of an AVC/H.264 NALU (Network Abstraction Layer Unit) parsing loop within a media streaming function. \n\nThe snippet extracts the size of individual NALUs from an AVC-encoded video sample. Here's what it does:\n\n1. **Size Extraction**: It reads the NALU size from the bitstream, where `avc_nalu_size` indicates how many bytes are used to encode the size (typically 1, 2, or 4 bytes)\n\n2. **Byte-by-byte Reading**: The `while (v)` loop reads each byte of the size field:\n   - Takes the current byte value `(u8) *ptr`\n   - Combines it with the running `size` value using bitwise OR\n   - Advances the pointer and decrements remaining bytes\n   - Shifts left by 8 bits for multi-byte sizes (except the last byte)\n\n3. **Big-endian Processing**: The size is read in big-endian format, building up the complete NALU size value progressively\n\nThis is a critical part of AVC/H.264 stream processing, as it allows the streamer to identify individual NALU boundaries within the compressed video data, enabling proper packetization for RTP streaming. The extracted size is then used to process each NALU separately for network transmission."}
